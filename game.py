# Code Generated by ChatGPT and modified by Me 
forest_map = [
    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 1, 1, 1, 0, 0, 1],
    [1, 0, 0, 0, 1, 1, 1, 0, 0, 1],
    [1, 1, 0, 1, 0, 0, 1, 0, 0, 1],
    [1, 1, 0, 0, 0, 0, 1, 0, 0, 1],
    [1, 1, 1, 0, 0, 0, 1, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 0, 0, 0, 1],
    [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 0, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
]

import pygame
import sys
import time

# Initialize Pygame
pygame.init()

# Constants
WIDTH, HEIGHT = 500, 500
TILE_SIZE = 50
WHITE = (255, 255, 255)
GREEN = (0, 255, 0)
RED = (255, 0, 0)

# Create the game window
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Pokemon Forest")

# Set initial player position
player_x, player_y = 2, 9

# Set initial NPC position and state
npc_x, npc_y = 8, 6
npc_directions = ["up", "down", "left", "right"]
npc_direction = "up"
npc_last_change_time = pygame.time.get_ticks()
npc_change_interval = 1000  # Change direction every 5 seconds
npc_engage_distance = 1  # Adjust the distance at which NPC engages the player

# Flag to check if the question is initiated
question_initiated = False


# Load and resize player and NPC character images
player_image = pygame.image.load("player.png")  # Replace with your player image
player_image = pygame.transform.scale(player_image, (TILE_SIZE, TILE_SIZE))

npc_image_up = pygame.image.load("npc_up.png")  # Replace with your NPC image facing up
npc_image_up = pygame.transform.scale(npc_image_up, (TILE_SIZE, TILE_SIZE))
npc_image_right = pygame.image.load("npc_right.png")  # Replace with your NPC image facing up
npc_image_right = pygame.transform.scale(npc_image_right, (TILE_SIZE, TILE_SIZE))
npc_image_down = pygame.image.load("npc_down.png")  # Replace with your NPC image facing up
npc_image_down = pygame.transform.scale(npc_image_down, (TILE_SIZE, TILE_SIZE))
npc_image_left = pygame.image.load("npc_left.png")  # Replace with your NPC image facing up
npc_image_left = pygame.transform.scale(npc_image_left, (TILE_SIZE, TILE_SIZE))

class Player:
    def __init__(self, name):
        self.name = name
        self.gpa = 3.00

        # Ensure GPA does not exceed 4.00
        self.gpa = min(self.gpa, 4.50)
    
# Player stats
player = Player("Ash")  # Use the Player class

# class FSM:
#     def __init__(self, initial_state):
#         # Dictionary (input_symbol, current_state) --> (action, next_state).
#         self.state_transitions = {}
#         self.current_state = initial_state

#     def add_transition(self, input_symbol, state, action=None, next_state=None):
#         """
#         Adds a transition to the instance variable state_transitions
#         that associates:
#             (input_symbol, current_state) --> (action, next_state)

#         The action may be set to None in which case the process() method will
#         ignore the action and only set the next_state.

#         The next_state may be set to None in which case the current state will be unchanged.
        
#         Args:
#             input_symbol (anything): The input received
#             state (anything): The current state
#             action (function, optional): The action to take/function to run. Defaults to None.
#             next_state (anything, optional): The next state to transition to. Defaults to None.
#         """
#         # TODO: implement add transition
#         if next_state != None:
#             self.state_transitions[(input_symbol, state)] = (action, next_state)
#         else:
#             self.state_transitions[(input_symbol, state)] = (action, state)


#     def get_transition(self, input_symbol, state):
#         """
#         Returns tuple (action, next state) given an input_symbol and state.
#         Normally you do not call this method directly. It is called by
#         process().

#         Args:
#             input_symbol (anything): The given input symbol
#             state (anything): The current state

#         Returns:
#             tuple: Returns the tuple (action, next_state)
#         """
#         # TODO: Implement get transition
#         return(self.state_transitions[(input_symbol, state)])
        

#     def process(self, input_symbol):
#         """
#         The main method that you call to process input. This may
#         cause the FSM to change state and call an action. This method calls
#         get_transition() to find the action and next_state associated with the
#         input_symbol and current_state. If the action is None then the action
#         is not called and only the current state is changed. This method
#         processes one complete input symbol.
#         Args:
#             input_symbol (anything): The input to process
#         """
#         # TODO: Implement process
#         update = self.get_transition(input_symbol, self.current_state)
#         if update[0] != None:
#             update[0]()
#         self.current_state = update[1]
        

# class NPC:
#     # States
#     UP, DOWN, LEFT, RIGHT = "u", "d", "r", "l"

#     # Inputs
#     TIMER_UP = "tu"
#     DIRECTIONS = {UP: npc_image_up, DOWN: npc_image_down, RIGHT: npc_image_right, LEFT: npc_image_left}


#     def __init__(self):
#         # Initialize FSM
#         self.fsm = FSM(self.DOWN)
#         self.init_fsm()
#         self.timer_duration = 1

#         # Start DOWN
#         self.turn_DOWN()
#         pygame.display.flip()

    # def init_fsm(self):
    #     """
    #     Adds all states to the FSM
    #     """
    #     self.fsm.add_transition(self.TIMER_UP, self.DOWN, self.turn_RIGHT, self.RIGHT)
    #     self.fsm.add_transition(self.TIMER_UP, self.RIGHT, self.turn_UP, self.UP)
    #     self.fsm.add_transition(self.TIMER_UP, self.UP, self.turn_LEFT, self.LEFT)
    #     self.fsm.add_transition(self.TIMER_UP, self.LEFT, self.turn_DOWN, self.DOWN)

    # def turn_RIGHT(self):
    #     screen.blit(self.DIRECTIONS[self.RIGHT], (npc_x * TILE_SIZE, npc_y * TILE_SIZE))
    #     self.timer_duration = 5
    
    # def turn_UP(self):
    #     screen.blit(self.DIRECTIONS[self.UP], (npc_x * TILE_SIZE, npc_y * TILE_SIZE))
    #     self.timer_duration = 5
    
    # def turn_DOWN(self):
    #     screen.blit(self.DIRECTIONS[self.DOWN], (npc_x * TILE_SIZE, npc_y * TILE_SIZE))
    #     self.timer_duration = 5
    
    # def turn_LEFT(self):
    #     screen.blit(self.DIRECTIONS[self.LEFT], (npc_x * TILE_SIZE, npc_y * TILE_SIZE))
    #     self.timer_duration = 5

def run(self):
        start_time = time.time()

        while True:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()

            elapsed_time = time.time() - start_time
            print(elapsed_time)
            if elapsed_time > self.timer_duration:
                self.fsm.process(self.TIMER_UP)
                start_time = time.time()
                pygame.display.flip()

            time.sleep(0.5)

# Question and answer data
question_data = {
    "question": "What is the capital of France?",
    "answers": ["London", "Paris", "Berlin", "Madrid"],
    "correct_answer": "Paris"
}

# Function to display player's GPA in the bottom right corner
def display_gpa(screen, font, player):
    gpa_text = font.render(f"GPA: {player.gpa:.2f}", True, (0, 0, 0))
    screen.blit(gpa_text, (WIDTH - 150, HEIGHT - 30))

# Function to handle the question sequence
def question_sequence():
    global player

    # Create a new Pygame window for the question
    question_screen = pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption("Question Time")

    # Draw a blank white background
    question_screen.fill(WHITE)

    # Display feedback text
    feedback_text = font.render("", True, (0, 0, 0))  # Initialize feedback text


    # Display question and answers
    question_text = font.render(question_data["question"], True, (0, 0, 0))
    question_screen.blit(question_text, (WIDTH // 2 - 150, HEIGHT // 2 - 100))

    answer_texts = []
    for i, answer in enumerate(question_data["answers"]):
        answer_text = font.render(f"{i + 1}. {answer}", True, (0, 0, 0))
        answer_texts.append(answer_text)
        question_screen.blit(answer_text, (WIDTH // 2 - 150, HEIGHT // 2 - 50 + i * 30))

    pygame.display.flip()
    

    # Wait for player input
    selected_answer = None
    while selected_answer is None:
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN:
                if pygame.K_1 <= event.key <= pygame.K_4:
                    answers = question_data["answers"]
                    selected_answer = answers[int(event.key - pygame.K_1)]
                elif event.key == pygame.K_ESCAPE:
                    sys.exit()

    # Check the selected answer
    correct_answer = question_data["correct_answer"]
    if selected_answer == correct_answer:
        feedback_text = font.render("Correct!", True, (0, 255, 0))
        # Handle correct answer
        player.gpa += 0.05
    else:
        feedback_text = font.render("Incorrect!", True, (255, 0, 0))
        # Handle incorrect answer
        player.gpa -= 0.1
    
    # Display feedback text at the top
    question_screen.blit(feedback_text, (WIDTH // 2 - 50, 20))
    
    # Display player's updated GPA in the bottom right corner
    display_gpa(question_screen, font, player)
    
    pygame.display.flip()

    # Wait for a moment to display feedback
    pygame.time.delay(2000)

    # Reset to the original Pokemon Forest screen
    question_initiated = False

# Font for displaying text
font = pygame.font.Font(None, 36)


# Game loop
clock = pygame.time.Clock()
running = True
while running:
    clock.tick(10)  # Adjust the speed of the game

    # Event handling
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # Player movement
    keys = pygame.key.get_pressed()
    next_x, next_y = player_x, player_y

    if keys[pygame.K_LEFT]:
        next_x -= 1
    elif keys[pygame.K_RIGHT]:
        next_x += 1
    elif keys[pygame.K_UP]:
        next_y -= 1
    elif keys[pygame.K_DOWN]:
        next_y += 1

    # Check if the next position is valid (not occupied by the NPC or a tree)
    if forest_map[next_y][next_x] == 0 and (next_x != npc_x or next_y != npc_y):
        player_x, player_y = next_x, next_y

    # NPC behavior - Change direction every 5 seconds
    current_time = pygame.time.get_ticks()
    if current_time - npc_last_change_time >= npc_change_interval:
        npc_last_change_time = current_time
        npc_direction = npc_directions[(npc_directions.index(npc_direction) + 1) % len(npc_directions)]

    if not question_initiated:
        if npc_x == player_x:
            if npc_y < player_y:
                npc_direction = "down"
            elif npc_y > player_y:
                npc_direction = "up"
        elif npc_y == player_y:
            if npc_x < player_x:
                npc_direction = "right"
            elif npc_x > player_x:
                npc_direction = "left"

        if npc_x - npc_engage_distance <= player_x <= npc_x + npc_engage_distance \
                and npc_y - npc_engage_distance <= player_y <= npc_y + npc_engage_distance:
            # Engage in a question sequence
            question_initiated = True
            question_sequence()

    # Draw background
    screen.fill(WHITE)

    # Draw forest map
    for y, row in enumerate(forest_map):
        for x, tile in enumerate(row):
            if tile == 1:
                pygame.draw.rect(screen, GREEN, (x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE))

    # Draw player character
    screen.blit(player_image, (player_x * TILE_SIZE, player_y * TILE_SIZE))

    # Draw NPC character
    if npc_direction == "up":
        screen.blit(npc_image_up, (npc_x * TILE_SIZE, npc_y * TILE_SIZE))
    # Add similar conditions for other directions
    if npc_direction == "right":
        screen.blit(npc_image_right, (npc_x * TILE_SIZE, npc_y * TILE_SIZE))
    if npc_direction == "down":
        screen.blit(npc_image_down, (npc_x * TILE_SIZE, npc_y * TILE_SIZE))
    if npc_direction == "left":
        screen.blit(npc_image_left, (npc_x * TILE_SIZE, npc_y * TILE_SIZE))



    # Display player's GPA in the bottom right corner
    display_gpa(screen, font, player)


    # Update display
    pygame.display.flip()

# Quit Pygame
pygame.quit()
sys.exit()
